19 单服务器高性能模式：Reactor与Proactor


1---PPC和TPC模式，实现简单，都无法支撑高并发的场景
    应对高并发场景的单服务器高性能架构模式：Reactor和Proactor
=============================================================
Reactor
    ·资源复用，不在单独为每个连接创建进程或线程，而是创建一个进程池，将连接分配给进程，一个进程可以处理多个连接。
    将read操作改为非阻塞，然后进程不断地轮询多个连接，这种方式能解决阻塞问题，但是解决的方式并不优雅。
    I/O多路复用技术的来源：只有当连接上有数据的时候进程才去处理。
        I/O多路复用技术两个关键实现点：
            当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的实现方式有select、epoll、kequeue
            当某条连接有新的的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。
        I/O多路复用结合线程池，完美解决了PPC和TPC的问题，这就是Reactor，反应器、事件反应
        来了一个事件我就有相应的反应——这个我就是Reactor、具体的反应就是我们写的代码，Reactor会根据事件类型来调用相应的代码进行处理。
    Reactor模式也叫做Dispatcher模式，即I/O多路复用统一监听事件，收到事件后分配Dispach给某个进程。
    --------------------------
    Reactor的核心组成部分包括Reactor和处理资源池（进程池或线程池）Reactor负责监听和分配事件，处理资源池负责处理事件。
            三种典型的实现方案：单Reactor 单进程/线程  无法发挥多核CPU的性能、只适用于业务处理非常快速的场景，如Redis
                                单Reactor 多线程       充分利用了多核CPU的处理能力，多线程数据共享和访问比较复杂,Reactor承担所有事件的监听和响应，只在主线程中运行，瞬间高并发会成为性能瓶颈。
                                多Reactor 多进程/线程  看似复杂，实际实现更为简单——父子进程职责明确，交互简单，子进程间互相独立。Nginx采用的是多Reactor多进程，Memcache和Netty采用 多Reactor多线程

Proactor
    Reactor是非阻塞同步网络模型，因为真正的read和send操作都需要用户进程同步操作。
    如果把I/O操作改为异步就能够进一步提升性能，这就是异步网络模型Proactor。
    Proactor 主动器 Reactor可以理解为"来了事件，我通知你，你来处理"
                    Proactor 可以理解为"来了事件，我来处理，处理完了我通知你"
                    这里的我指的是操作系统内核，事件--就是有新连接、有数据可读、有数据可写这些I/O事件，你——就是我们的程序代码。
    理论上Proactor比Reactor效率要高一些，异步I/O能充分利用DMA特性，让I/O操作与计算重叠，但要实现真正的异步I/O操作，操作系统需要做大量的工作。
    目前，Linux下实现高并发网络编程时都是以Reactor模式为主。

===========================================================
其他知识点：

1-I/O操作
    I/O操作分两个阶段：
        a等待数据准备好（读到内核缓存）
        b将数据从内核读到用户空间（进程空间）
    一般来说a花费的时间远远大于 b
    a上阻塞b上也阻塞的是同步阻塞I/O
    a上非阻塞b上阻塞的是同步非阻塞I/O,Reactor模式就是这种模型
    a上非阻塞b上也非阻塞的是异步非阻塞I/O,Preactor模式就是这种模型
2-连接和请求
    连接理解为一tcp连接
    请求立即为——一次sql语句执行
3-轮询的理解
    两个轮询不是一个意思，select和poll是收到通知后轮询socket列表看看哪个socket可以读，普通的socket轮询是指重复调用read操作。

  






